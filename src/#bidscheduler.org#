* bid scheduler
接受用户的资源请求，通过竞价方式决定是否满足用户的资源需求
** 依赖monitor接口：
获取系统总资源量(cpu，内存),总运行时间    5
获取系统总CPU使用量，内存使用量    5
获取当前系统cpu使用量，内存使用量    1
每个用户的总系统cpu使用率，内存使用率    4
每个物理机的总资源量，总运行时间，当前系统cpu使用量，内存使用量    1
#+name: import
#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  from monitor import summary_resources, summary_usage, curr_usage
  from monitor import summary_usage_per_user, summary_usage_per_user
  from monitor import curr_usage_per_machine
  import nodemgr
#+END_SRC
** 提供的接口：
*** 显示资源分配情况
显示当前系统的资源分配情况,系统资源分为两种：
可靠资源，即受到隔离保护的资源，使用cgroup的cpu和memeory保护
受限制资源：使用cgroup的软限制分配的资源，当系统cpu或者内存不足时，将会减少这些容器的资源
#+name: global_variables
#+BEGIN_SRC pyhon :noweb yes
allocations = {}
nodemanager
#+END_SRC
#+BEGIN_SRC python :noweb yes :tangle bidscheduler.py

  class AllocationOfTask(object):
      __slots__ = 'uuid','userid','jobid','taskid','resources','bidprice','type'

  class AllocationOfMachine(object):
      __slots__ = 'machineid',"resources","reliable_resources_allocation_summary",
                  'reliable_allocation','curr_usage', 'restricted_allocation'

  def init_allocations():
      global allocations
      global nodemanager
      machines = nodemanager.get_allnodes()
      for machine in machines:
          allocation = AllocationOfMachine()
          allocation.machineid = machine
          allocation.resources = 100
          allocation.reliable_resources_allocation_summary = 0
          allocation.reliable_allocation = []
          allocation.restricted_allocation = []

          allocations[machine] = allocation


  def has_reliable_resources(allocation_of_machine,task_allocation_request):
      if(task_allocation_request['resource']
         +allocation_of_machine.reliable_resources_allocation_summary
         < allocation_of_machine.resources):
          return True
      else:
          return False

  def can_preempt_reliable_resources(taskAllocationRequest):
      to_be_preempted=0
      for a in reliable_allocation:
          if (a.bidprice< task_allocation_request['bidprice']):
              to_be_preempted += a.bidprice
              if to_be_preempted > task_allocation_request['resource']:
                  return True
          else:
              break
          return False

  def has_restricted_resources(allocation_of_machine,task_allocation_request):
      if(task_allocation_request['resources']
         + curr_usage
         < allocation_of_machine.resources * 0.8):
          return True
      else:
          return False

  import uuid, bisect
  def allocate_task(allocation_of_machine,task_allocation_request):
      if(has_reliable_resources(request)):
          allocation_of_task = AllocationOfTask()
          allocation_of_task.id = uuid.uuid4()
          allocation_of_task.userid = task_allocation_request['userid']
          allocation_of_task.jobid = task_allocation_request['jobid']
          allocation_of_task.taskid = task_allocation_request['taskid']
          allocation_of_task.bidprice = task_allocation_request['bidprice']
          allocation_of_task.type = 'reliable'
          bisect.insort(allocation_of_machine.reliable_allocation, allocation_of_task, lambda x: x.bidprice)
          return {status:success, allocation:allocation_of_task}

      if(can_preempt_reliable_resources(task_allocation_request)):
          can_preempt = 0
          can_preempt_count = 0
          # 把被抢占的可靠资源变成受限制资源
          for i,a in reliableAllocation:
              can_preempt+=a['slots']
              can_preempt_count+=1
              a.type = 'restricted'
              import bisect
              bisect.insort(allocation_of_machine.restricted_allocation,a, lambda x: x.bidprice)
              # to-do 调整这些容器的cgroup设置，使用软限制模式，只能使用空闲资源

              if can_preempt>=task_allocation_request['resources']:
                  break
              # 把被抢占的可靠资源从reliable_allocation中删除
          del reliable_allocations[0..can_preempt_count]

          allocation_of_task = AllocationOfTask()
          allocation_of_task.id = uuid.uuid4()
          allocation_of_task.userid = task_allocation_request['userid']
          allocation_of_task.jobid = task_allocation_request['jobid']
          allocation_of_task.taskid = task_allocation_request['taskid']
          allocation_of_task.bidprice = task_allocation_request['bidprice']
          allocation_of_task.type = 'reliable'
          bisect.insort(allocation_of_machine.reliable_allocation,AllocationOfTask)
          return {status:success, allocation:allocation}

      if(has_restricted_resources(task_allocation_request)):
          allocation_of_task = AllocationOfTask()
          allocation_of_task.id = uuid.uuid4()
          allocation_of_task.userid = task_allocation_request['userid']
          allocation_of_task.jobid = task_allocation_request['jobid']
          allocation_of_task.taskid = task_allocation_request['taskid']
          allocation_of_task.bidprice = task_allocation_request['bidprice']
          allocation_of_task.type = 'restricted'
          bisect.insort(allocation_of_machine.restricted_allocation,AllocationOfTask)
          return {status:'success', allocation:allocation_of_task}

      else:
          return {status: 'failed'}

  def allocate_task_restricted(allocation_of_machine,task_allocation_request):
      if(has_restricted_resources(task_allocation_request)):
          allocation_of_task = AllocationOfTask()
          allocation_of_task.id = uuid.uuid4()
          allocation_of_task.userid = task_allocation_request['userid']
          allocation_of_task.jobid = task_allocation_request['jobid']
          allocation_of_task.taskid = task_allocation_request['taskid']
          allocation_of_task.bidprice = task_allocation_request['bidprice']
          allocation_of_task.type = 'restricted'
          bisect.insort(allocation_of_machine.restricted_allocation,AllocationOfTask)
          return {status:'success', allocation:allocation_of_task}

      else:
          return {status: 'failed'}


  def allocate(job_allocation_request):
      global allocations
      job_allocation_response = []
      sorted(allocations,lambda x: x.reliable_resources_allocation_summary )

      # 先从可靠资源最多的机器分配资源
      for i in range(job_allocation_request['tasks_count']):
          task_allocation_request = {
              userid: job_allocation_request['userid'],
              jobid: job_allocation_request['jobid'],
              taskid: i,
              bidprice: job_allocation_request['bidprice'],
              resources: job_allocation_request['resources'],
          }
          if( has_reliable_resource(allocations[i],task_allocation_request)
              or can_preempt_reliable_resources(allocations[i],task_allocation_request)):
              task_allocation_response = allocate_task(task_allocation_request)
              job_allocation_response.add(task_allocation_response)
          else:
              break

      if (job_allocation_response.size == job_allocation_request['taskcount']):
          return job_allocation_response
      else:
          # 从restricted_resources中选择使用率最低的机器
          global usage_per_machine
          sorted(usage_per_machine, lambda x: x.cpu_utilization, reverse=True)
          for i in range(job_allocation_response.size..job_allocation_request['taskcount']):
              machineid = usage_per_machine[i]['machineid']
              allocation_of_machine = allocations[machineid]
              task_allocation_request = {
                  userid: job_allocation_request['userid'],
                  jobid: job_allocation_request['jobid'],
                  taskid: i,
                  bidprice: job_allocation_request['bidprice'],
                  resources: job_allocation_request['resources']
              }
              task_allocation_response = allocate_restricted(allocation_of_machine,task_allocation_request)
              job_allocation_response.add(task_allocation_response)

      return job_allocation_response
#+END_SRC
#+BEGIN_SRC yaml :tangle ../doc/bidscheduler.yaml
---
- machineId: 0
  resources: 10
  reliable_resources_allocated_summary: 8
  reliable_resources_left: 2
  reliable_resources_allocated:
      - userId: 1401214302
        jobId:  001
        taskId: 001001
        resources: 2
        bidprice: 4
      - userId: 1401214302
        jobId:  002
        taskId: 002001
        resources: 2
        bidprice: 5
  curr_usage: 4
  restricted_resources: 6
  restricted_resources_allocated:
      - uuid: 1234567
        userId: 1401214302
        jobId:  001
        taskId: 001001
        resources: 2
        bidprice: 1
      - uuid: 12345678
        userId: 1401214302
        jobId:  001
        taskId: 001001
        resources: 2
        bidprice: 1
#+END_SRC
*** 处理分配资源请求
用户在创建集群时，填写所需资源和出价，系统接受资源分配请求，并依据以下规则决定如何分配
系统具有未分配的可靠资源，把这些可靠资源分配给该请求
#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  def has_reliable_resources(request):
      if(request['slots']+allocated_resources<summary_resources['slots']):
          return True
      else:
          return False

#+END_SRC
系统资源已分配完毕，用户出价足够高，可以抢占可靠资源
#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  def can_preempt_relibale_resources(request):
      reliable_allocated_sorted_by_bid = sorted(reliable_allocated, key=lambda k:k['bidprice'])
      can_be_preempted=0
      for a in reliable_allocated_sorted_by_bid:
          if(a['bidprice']<request['bidprice']):
              can_be_preempted += a['slots']
              if can_be_preempted>request['slots']:
                  return True
          else:
              break
      return False
#+END_SRC
系统资源已分配完毕，用户出价不足以抢到可靠资源，但是还有空闲资源可用
#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  def has_restricted_resources(request):
      if request['slots']+curr_usage['slots']<summary_resources['slots']:
          return True
      else:
          return False
#+END_SRC

系统资源已分配完毕，用户出价抢不到可靠资源，也抢不到空闲资源


#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  <<global_variables>>
  def allocate_resources(request):
      global allocated_resources
      global relibale_allocated
      global relibale_allocated_sorted_by_bid
      global restricted_allocated
      global restricted_allocated_sorted_by_bid

      if(has_reliable_resources(request)):
          allocated_machine=sorted_usage_per_machine.keys[0]
          reliable_allocation={userId: request['userId'],
                               slots: request['slots'],
                               machine: allocated_machine,
                               bidprice: request['bidprice']}
          reliable_allocations.insert(reliable_allocation)
          #  to-do 把reliable_allocation插入reliable_allocation_sorted_by_bid,并且保持有序
          allocation = {userId: request['userId'],
                        slots: request['slots'],
                        machine: allocated_machine,
                        bidprice: request['bidprice'],
                        type: reliable}
          return {status:success, allocation:allocation}

      if(can_preempt_reliable_resources(request)):
          can_preempt = 0
          can_preempt_count = 0
          # 把被抢占的可靠资源变成受限制资源
          for i,a in reliable_allocation_sorted_by_bid:
              can_preempt+=a['slots']
              can_preempt_count+=1
              restricted_allocation={userId: request['userId'],
                                     slots: request['slots'],
                                     machine: allocated_machine,
                                     bidprice: request['bidprice']}
              restricted_allocations.insert(restricted_allocation)
              # to-do 同时把restricted_allocation插入restricted_allocations_sorted_by_bid，并保持有序

              if can_preempt>=request['slots']:
                  break
          # 把被抢占的可靠资源从reliable_allocation中删除
          del reliable_allocations[0..can_preempt_count]

          # to-do 同时从reliable_allocation_sorted_by_bid中删除

          # to-do 以下寻找实际分配的物理机的方法暂时是错的
          allocated_machine=reliable_allocation_sorted_by_bid[0]['machine']

          reliable_allocation={userId: request['userId'],
                               slots: request['slots'],
                               machine: allocated_machine}
          reliable_allocations.insert(reliable_allocation)
          allocation = {userId: request['userId'],
                        slots: request['slots'],
                        machine: allocated_machine,
                        type: reliable}
          return {status:success, allocation:allocation}

      if(has_restricted_resources(request)):
          sorted_usage_per_machine = sorted(usage_per_machine, key=lambda k: k['usage'], reverse=True)
          allocated_machines=sorted_usage_per_machine.keys[0]
          restricted_allocation={userId: request['userId'],
                                 slots: request['slots'],
                                 machines: allocated_machine}
          restricted_allocations.insert(restricted_allocation)
          allocation = {userId: request['userId'],
                        slots: request['slots'],
                        machines: allocated_machines,
                        type: restricted}
          allocations.insert(allocation)
          return {status:'success', allocation:allocation}

      else:
          return {status: 'failed'}
#+END_SRC
*** 释放资源
*** 考虑弹性伸缩
