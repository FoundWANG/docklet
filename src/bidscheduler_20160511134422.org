* bid scheduler
接受用户的资源请求，通过竞价方式决定是否满足用户的资源需求
对外提供的接口：
** 依赖monitor接口：
获取系统总资源量(cpu，内存),总运行时间
获取系统总CPU使用量，内存使用量
获取当前系统cpu使用量，内存使用量
每个用户的总系统cpu使用率，内存使用率
每个物理机的当前系统cpu使用量，内存使用量
#+name: import_monitor
#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  from monitor import summary_resources, summary_usage, curr_usage
  from monitor import per_user_summary_usage, per_user_summary_usage
  from monitor import per_machine_curr_usage
#+END_SRC
** 提供的接口：
*** 显示资源分配情况
显示当前系统的资源分配情况,系统资源分为两种，可靠资源，即受到隔离保护的资源，使用cgroup的cpu和memeory限制的
#+BEGIN_SRC pyhon :tangle bidscheduler.py :noweb yes
reliable_allocated = []
restricted_allocated = []
#+END_SRC
*** 处理分配资源请求
用户在创建集群时，填写所需资源和出价，系统接受资源分配请求，并依据以下规则决定如何分配
系统具有未分配资源，请求得到满足
#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  def has_reliable_resources(request):
      if(request['slots']+allocated_resources<summary_resources['slots']):
          return True
      else:
          return False

#+END_SRC
系统资源已分配完毕，用户出价足够高，可以抢占可靠资源
#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  def can_preempt_relibale_resources(request):
      reliable_allocated_sorted_by_bid = sorted(reliable_allocated, key=lambda k:k['bidprice'])
      can_be_preempted=0
      for a in reliable_allocated_sorted_by_bid:
          if(a['bidprice']<request['bidprice']):
              can_be_preempted += a['slots']
              if can_be_preempted>request['slots']:
                  return True
          else:
              break
      return False
#+END_SRC
系统资源已分配完毕，用户出价不足以抢到可靠资源，但是还有空闲资源可用
#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  def has_restricted_resources(request):
      if request['slots']+curr_usage['slots']<summary_resources['slots']:
          return True
      else:
          return False
#+END_SRC
系统资源已分配完毕，用户出价不足以抢到可靠资源，但足以抢到受限资源
#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  def can_preempt_restricted_resources(request):
      restricted_allocated_sorted_by_bid = sorted(reliable_allocated, key=lambda k:k['bidprice'])
      can_be_preempted=0
      for a in restricted_allocated_sorted_by_bid:
          if(a['bidprice']<request['bidprice']):
              can_be_preempted += a['slots']
              if can_be_preempted>request['slots']:
                  return True
          else:
              break
      return False
#+END_SRC
系统资源已分配完毕，用户出价抢不到可靠资源，也抢不到空闲资源
#+BEGIN_SRC python :tangle bidscheduler.py :noweb yes
  def allocate_resources(request):
      global allocated_resources
      global relibale_allocated
      global relibale_allocated_sorted_by_bid
      global restricted_allocated
      global restricted_allocated_sorted_by_bid
      if(has_reliable_resources(request)):
          allocated_machine=sorted_usage_per_machine.keys[0]
          reliable_allocation={userId: request['userId'],
                                 resources: request['slots'],
                                 machine: allocated_machine,
                                 bidprice: request['bidprice']}
          reliable_allocations.insert(reliable_allocation)
          #  to-do 把reliable_allocation插入reliable_allocation_sorted_by_bid,并且保持有序
          allocation = {userId: request['userId'],
                        slots: request['slots'],
                        machine: allocated_machine,
                        bidprice: request['bidprice'],
                        type: reliable}
          return {status:success, allocation:allocation}
      if(can_preempt_restricted_resources(request)):
          can_preempt = 0
          can_preempt_count = 0
          # 把被抢占的可靠资源变成受限制资源
          for i,a in reliable_allocation_sorted_by_bid:
              can_preempt+=a['slots']
              can_preempt_count+=1
              restricted_allocation={userId: request['userId'],
                                     slots: request['slots'],
                                     machine: allocated_machine,
                                     bidprice: request['bidprice']}
              restricted_allocations.insert(restricted_allocation)
              # to-do 同时把restricted_allocation插入restricted_allocations_sorted_by_bid，并保持有序

              if can_preempt>=request['slots']:
                  break
          # 把被抢占的可靠资源从reliable_allocation中删除
          del reliable_allocations[0..can_preempt_count]

          # to-do 同时从reliable_allocation_sorted_by_bid中删除

          # to-do 以下寻找实际分配的物理机的方法暂时是错的
          allocated_machine=reliable_allocation_sorted_by_bid[0]['machine']

          reliable_allocation={userId: request['userId'],
                               slots: request['slots'],
                               machine: allocated_machine}
          reliable_allocations.insert(reliable_allocation)
          allocation = {userId: request['userId'],
                        slots: request['slots'],
                        machine: allocated_machine,
                        type: reliable}
          return {status:success, allocation:allocation}
      if(has_restricted_resources(request)):
          sorted_usage_per_machine = sorted(usage_per_machine, key=lambda k: k['usage'], reverse=True)
          allocated_machines=sorted_usage_per_machine.keys[0]
          restricted_allocation={userId: request['userId'],
                                 resources: request['slots'],
                                 machines: allocated_machine}
          restricted_allocations.insert(restricted_allocation)
          allocation = {userId: request['userId'],
                        resources: request['slots'],
                        machines: allocated_machines,
                        type: restricted}
          allocations.insert(allocation)
          return {status:success, allocation:allocation}
      if(can_preempt_restricted_resources(request)):
          return {status:success, allocation:allocation}
      else:
          return {status:failed}
#+END_SRC
*** 释放资源
*** 考虑弹性伸缩
